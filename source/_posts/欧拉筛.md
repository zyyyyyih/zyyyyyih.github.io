---
title: 欧拉筛
tags:
  - C++
  - 算法
categories:
  - 学习
katex: true
math: true
abbrlink: 96683d0c
date: 2020-10-28 12:30:50
---
# 埃氏筛（普通筛法）
[埃拉托斯特尼筛法](https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984)，简称埃氏筛或爱氏筛，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。
时间复杂度为$O(nlogn)$
$E = mc^2$
$$E = mc^2$$
## 思想
要得到自然数n以内的全部素数，必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数。
## 算法实现
由以上的思想，很容易可以想出相应的算法
数学上定义1不是素数也不是合数
已知2，3，5.....为素数
所以，我们可以使用循环从2开始遍历，直到所需要的大小
### 演算过程
遍历到2时，把2的倍数都标记为不是素数。
接着遍历3，判断3未被标记过，于是认定3为素数，把3的倍数都标记以一遍
接着遍历4，判断4已经被标记过，所以continue，遍历下一个
......
### 代码实现
```cpp
bool a[MAXN] = {true};//用来表示各个数的标记状态的数组，MAXN为所需要的范围，全局变量默认为零，初始化
void prime(int n)
{
    
    for (int i = 2; i <= n; i ++)
    {
        if (!a[i]) continue;
        for (int j = 2 * i; j <= n; j += i)
        {
            a[j] = false;
        }
    }
}
void askk(int n) //用于查询n是否为素数
{
    return a[n] ? true : false;
}
```

```cpp
int pri[MAXN];//用于储存素数
void prime(int n)
{
    int cnt = 0;//计数器
	pri[++cnt] = 2;//第一个素数为2，此时pri[1]的值为2;
	for(int i = 3; i <= n; i++)//从3开始
	{
		for(int j = 2; j < i; j++)//是否有因数
		{
			if(i % j != 0) break;//找到了因数直接退出
		}
		if(j >= i)//此时如果j小于i，表示提前退出了，证明有因数，反之没有，可以将此数储存
			pri[++cnt] = i;
	}
}
```
# 欧拉筛（线性筛法）
线性筛，复杂度为 $ O(n) $ 。与埃氏筛相比，不会对已经被标记过的合数再进行重复标记，故效率更高。
## 思想
欧拉筛将合数分解为 (最小质因数 * 一个合数) 的形式，通过最小质因数来判断当前合数是否已经被标记过。
## 算法实现
先看代码
```cpp
int prime[MAXN];//存素数
bool vis[MAXN];//是否标记
int cnt = 0;
void Euler_prime(int n)
{
	for(int i = 2; i <= n; i++)
	{
		if(!vis[i]) 
        prime[cnt++] = i;//没标记就是素数，存起来
		for(int j = 0; j < cnt; j++)
		{
			if(i * prime[j] > n) break;//判断是否越界

			vis[i * prime[j]] = true;//筛数
			
            if(i % prime[j] == 0) break;//时间复杂度为O(n)的关键！
		}
	}
}
```
欧拉筛的难点就在于对`if (i % prime[j] == 0)`这步的理解
当`i % prime[j] == 0`时,即i是它的整数倍，令 `x = i / prime[j]`，那么 `i * prime[j + 1]` 就可以变为 `(x * prime[j+1]) * prime[j]`
这说明 `i * prime[j + 1]` 是 `prime[j]` 的整数倍，不需要再进行标记，因为之后会被 prime[j] * 某个数 标记，
对之后的素数的倍数进行标记时同理，直接跳出循环，这样就避免了重复标记。